# ApiClient.WaitForCollisionEvent method

Wait for a collision event to fire on an element that is being monitored for collisions. If the method has been called before, there is the potential that another event was recieved before waiting on the event again. Check with [`GetNextCollisionEvent`](./GetNextCollisionEvent.md) to see if it returns null to see if an event was missed.

```csharp
public Collision WaitForCollisionEvent(string eventId, int timeout = 60)
```

| parameter | description |
| --- | --- |
| eventId | The eventId received from the [`RegisterCollisionMonitor`](./RegisterCollisionMonitor.md) call. |
| timeout | The number of seconds to wait for a collision event to be fired. |

## Return Value

The Collision contains information about the collision. NULL is returned if the request times out.

## Examples

```csharp
// Register a Collision event, which returns a string ID.
// Note: This should be done for the moving/controlled object which has the RigidBody attached
string id = api.RegisterCollisionMonitor("//*[@name='Ellen']");

// Move the player character to the enemy character to initiate the collision.
// Movement in this example is expected to take several seconds.
api.NavAgentMoveToPoint("//*[@name='Ellen']", new Vector3(chomper.x, chomper.y, chomper.z), false);

// Wait for a collision event to occur, capturing the ID from the registered monitor above.
Collision didFire = api.WaitForCollisionEvent(id);

// Check if the event was detected. This could be where the test performs some action as a result of the event.
if (didFire != null)
    Console.WriteLine("Got event.");
else
    Console.WriteLine("Never got event...");
```

## See Also

* class [ApiClient](../ApiClient.md)
* namespace [gdio.unity_api.v2](../../gdio.unity_api.md)

<!-- DO NOT EDIT: generated by xmldocmd for gdio.unity_api.dll -->
